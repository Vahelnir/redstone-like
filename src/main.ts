import "./style.css";
import {
  WebGLRenderer,
  Raycaster,
  Vector2,
  PerspectiveCamera,
  Scene,
  HemisphereLight,
  Object3D,
} from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

import { Position } from "./core/position";
import { displayBlocks } from "./renderer/display-blocks";

import { RedstoneCable } from "./core/blocks/redstone-cable";
import { RedstoneElement } from "./core/blocks/redstone-element";
import { RedstoneInvertor } from "./core/blocks/redstone-invertor";
import { RedstoneButton } from "./core/blocks/redstone-button";
import { RedstoneNetwork } from "./core/network/redstone-network";

const rendererSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const renderer = new WebGLRenderer();
renderer.setSize(rendererSize.width, rendererSize.height);
document.body.appendChild(renderer.domElement);

const camera = new PerspectiveCamera(
  80,
  rendererSize.width / rendererSize.height,
  0.1,
  1000,
);

camera.position.z = 5;

const scene = new Scene();

const light = new HemisphereLight(0xffffff, 0x444444);
scene.add(light);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.25;

// const redstones: RedstoneElement[] = [
//   new RedstoneSource(new Position(-2, 0, 0)),
//   new RedstoneCable(new Position(-1, 0, 0)),
//   new RedstoneCable(new Position(-1, 0, -1)),
//   new RedstoneCable(new Position(-1, 0, -2)),
//   new RedstoneCable(new Position(0, 0, -2)),
//   new RedstoneCable(new Position(1, 0, -2)),
//   new RedstoneCable(new Position(2, 0, -2)),
//   new RedstoneRepeater(new Position(2, 0, -3), "north"),
//   new RedstoneCable(new Position(2, 0, -4)),
//   new RedstoneInvertor(new Position(2, 0, -5), "north"),
//   new RedstoneCable(new Position(2, 0, -6)),
//   new RedstoneCable(new Position(3, 0, -2)),
//   new RedstoneCable(new Position(4, 0, -2)),
//   new RedstoneSource(new Position(5, 0, -2)),
//   new RedstoneCable(new Position(0, 0, 0)),
//   new RedstoneCable(new Position(1, 0, 0)),
//   new RedstoneCable(new Position(1, 1, 1)),
//   new RedstoneCable(new Position(2, 1, 0)),
//   new RedstoneActivable(new Position(3, 1, 0)),
//   new RedstoneActivable(new Position(4, 1, 0)),

//   new RedstoneCable(new Position(5, 0, 5)),
//   new RedstoneCable(new Position(4, 1, 5)),
//   new RedstoneCable(new Position(5, 1, 4)),
//   new RedstoneCable(new Position(5, 1, 6)),
//   new RedstoneCable(new Position(6, 1, 5)),
// ];

// LOOP
// const redstones: RedstoneElement[] = [
//   new RedstoneInvertor(new Position(0, 0, -2), "east"),
//   new RedstoneCable(new Position(1, 0, -1)),
//   new RedstoneCable(new Position(1, 0, -2)),
//   new RedstoneCable(new Position(-1, 0, -2)),
//   new RedstoneInvertor(new Position(0, 0, 1), "west"),
//   new RedstoneCable(new Position(1, 0, 1)),
//   new RedstoneCable(new Position(-1, 0, 1)),
//   new RedstoneCable(new Position(-1, 0, -1)),
//   new RedstoneRepeater(new Position(-1, 0, 0), "north"),
//   new RedstoneRepeater(new Position(1, 0, -1), "south", 2),
//   new RedstoneRepeater(new Position(1, 0, 0), "south", 2),
// ];

const redstones: RedstoneElement[] = [
  new RedstoneButton(new Position(0, 0, 0)),
  new RedstoneCable(new Position(1, 0, 0)),
  new RedstoneInvertor(new Position(2, 0, 0), "east"),
  new RedstoneCable(new Position(3, 0, 0)),
  new RedstoneCable(new Position(4, 0, 0)),
  new RedstoneCable(new Position(4, 0, 1)),
  new RedstoneInvertor(new Position(4, 0, 2), "west"),
  new RedstoneCable(new Position(3, 0, 2)),
  new RedstoneCable(new Position(2, 0, 2)),
  new RedstoneCable(new Position(2, 0, 1)),

  new RedstoneCable(new Position(4, 0, 3)),
  new RedstoneButton(new Position(4, 0, 4)),
];

const world = new Map<string, RedstoneElement>(
  redstones.map((redstone) => [redstone.position.toStringKey(), redstone]),
);

const redstoneNetwork = new RedstoneNetwork(world);

console.log(redstones);
displayBlocks(scene, world);

const raycaster = new Raycaster();
const mouse = new Vector2();

renderer.domElement.addEventListener("pointerdown", (event) => {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const meshes = Array.from(world.keys())
    .map((id) => world.get(id)?.getMesh())
    .filter((m): m is Object3D => m !== null);
  const intersects = raycaster.intersectObjects(meshes, false);
  if (intersects.length > 0) {
    const mesh = intersects[0].object;
    const block = world.get(Position.fromVector3(mesh.position).toStringKey());
    if (block && "onClick" in block && typeof block.onClick === "function") {
      block.onClick?.();
    }
  }
});

let lastTick = performance.now();
const TICKS_PER_SECOND = 10;
const TICK_INTERVAL = 1000 / TICKS_PER_SECOND;

// FPS/TPS overlay generated by copilot
const statsOverlay = document.createElement("div");
statsOverlay.style.position = "absolute";
statsOverlay.style.bottom = "10px";
statsOverlay.style.left = "10px";
statsOverlay.style.padding = "8px 14px";
statsOverlay.style.background = "rgba(0,0,0,0.7)";
statsOverlay.style.color = "#fff";
statsOverlay.style.fontFamily = "monospace";
statsOverlay.style.fontSize = "16px";
statsOverlay.style.zIndex = "200";
statsOverlay.style.borderRadius = "8px";
document.body.appendChild(statsOverlay);

let lastFpsUpdate = performance.now();
let frameCount = 0;
let fps = 0;
let tps = 0;

function updateStatsOverlay() {
  statsOverlay.textContent = `FPS : ${fps} | TPS : ${tps}`;
}

let ticking = false;
function loop(t = 0) {
  const now = performance.now();
  if (ticking) {
    let tickCount = 0;
    while (now - lastTick >= TICK_INTERVAL) {
      tick();
      lastTick += TICK_INTERVAL;
      tickCount++;

      // try to avoid blocking the main thread for too long
      if (tickCount > 5) {
        lastTick = now;
        break;
      }
    }
  }

  controls.update();
  redstones.forEach((r) => r.render());
  renderer.render(scene, camera);

  frameCount++;
  if (now - lastFpsUpdate >= 1000) {
    fps = frameCount;
    frameCount = 0;
    lastFpsUpdate = now;
    const oneSecondAgo = now - 1000;
    const ticksLastSecond = tickTimestamps.filter(
      (ts) => ts >= oneSecondAgo,
    ).length;
    tps = ticksLastSecond;
    updateStatsOverlay();
  }
  requestAnimationFrame(loop);
}

const TICK_HISTORY = 60;
const tickTimestamps: number[] = [];

function tick() {
  const now = performance.now();
  redstoneNetwork.tick();
  tickTimestamps.push(now);
  if (tickTimestamps.length > TICK_HISTORY) {
    tickTimestamps.shift();
  }
}

const toolbar = document.createElement("div");
toolbar.style.position = "absolute";
toolbar.style.top = "0";
toolbar.style.left = "0";
toolbar.style.height = "50px";
toolbar.style.background = "rgba(0, 0, 0, 0.5)";
toolbar.style.display = "flex";
toolbar.style.alignItems = "center";
toolbar.style.padding = "0 10px";
toolbar.style.boxSizing = "border-box";
toolbar.style.zIndex = "100";
toolbar.style.gap = "5px";
document.body.appendChild(toolbar);

const startTicksButton = document.createElement("button");
startTicksButton.textContent = "Start Ticking";
startTicksButton.style.padding = "10px";
startTicksButton.style.zIndex = "100";
startTicksButton.onclick = () => {
  if (!ticking) {
    startTicksButton.textContent = "Stop Ticking";
    ticking = true;
  } else {
    startTicksButton.textContent = "Start Ticking";
    ticking = false;
  }
};
toolbar.appendChild(startTicksButton);

const tickButton = document.createElement("button");
tickButton.textContent = "Tick";
tickButton.style.padding = "10px";
tickButton.style.zIndex = "100";
tickButton.onclick = () => {
  tick();
};
toolbar.appendChild(tickButton);

loop();
