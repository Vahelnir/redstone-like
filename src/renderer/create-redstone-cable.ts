import {
  BoxGeometry,
  Mesh,
  MeshStandardMaterial,
  Sprite,
  SpriteMaterial,
  Texture,
  Vector3,
} from "three";
import { mergeGeometries } from "three/addons/utils/BufferGeometryUtils.js";

type Directions = {
  north?: boolean | "up";
  south?: boolean | "up";
  east?: boolean | "up";
  west?: boolean | "up";
};

const REDSTONE_CABLE_COLORS = [
  0x4b0000, 0x5e0000, 0x700000, 0x830000, 0x960000, 0xa80000, 0xbb0000,
  0xcd0000, 0xe00000, 0xf20000, 0xff1a1a, 0xff3333, 0xff4b4b, 0xff6666,
  0xff7f7f, 0xff9999,
];

export function createRedstoneCable({
  directions,
  position,
  power = 0,
}: {
  directions: Directions;
  position?: Vector3;
  power?: number;
}) {
  const color = REDSTONE_CABLE_COLORS[Math.min(Math.max(power, 0), 15)];
  const mesh = getRedstoneMesh(directions);
  mesh.material.color.setHex(color);
  if (position) {
    mesh.position.copy(position);
  }
  mesh.add(createRedstonePowerText(power, { x: 0, y: 0, z: 0 }));
  return mesh;
}

function getRedstoneMesh(directions: Directions) {
  const geometries = [];
  const height = 0.01;
  const centerOffset = -(1 - 0.02) / 2;

  const centerGeom = new BoxGeometry(0.3, height, 0.3);
  centerGeom.translate(0, centerOffset, 0);
  geometries.push(centerGeom);

  if (directions.north) {
    const geom = new BoxGeometry(0.1, height, 0.4);
    geom.translate(0, centerOffset, -0.3);
    geometries.push(geom);
    if (directions.north === "up") {
      const upGeom = new BoxGeometry(0.1, 1, height);
      upGeom.translate(0, 0, centerOffset);
      geometries.push(upGeom);
    }
  }

  if (directions.south) {
    const geom = new BoxGeometry(0.1, height, 0.4);
    geom.translate(0, centerOffset, 0.3);
    geometries.push(geom);
    if (directions.south === "up") {
      const upGeom = new BoxGeometry(0.1, 1, height);
      upGeom.translate(0, 0, -centerOffset);
      geometries.push(upGeom);
    }
  }

  if (directions.east) {
    const geom = new BoxGeometry(0.4, height, 0.1);
    geom.translate(0.3, centerOffset, 0);
    geometries.push(geom);
    if (directions.east === "up") {
      const upGeom = new BoxGeometry(height, 1, 0.1);
      upGeom.translate(-centerOffset, 0, 0);
      geometries.push(upGeom);
    }
  }

  if (directions.west) {
    const geom = new BoxGeometry(0.4, height, 0.1);
    geom.translate(-0.3, centerOffset, 0);
    geometries.push(geom);
    if (directions.west === "up") {
      const upGeom = new BoxGeometry(height, 1, 0.1);
      upGeom.translate(centerOffset, 0, 0);
      geometries.push(upGeom);
    }
  }

  const merged = mergeGeometries(geometries);
  return new Mesh(merged, new MeshStandardMaterial());
}

// TODO: see if rewriting this is necessary because it was generated by copilot
export function createRedstonePowerText(
  value: number | string,
  position: { x: number; y: number; z: number },
) {
  const canvas = document.createElement("canvas");
  canvas.width = 128;
  canvas.height = 64;

  const ctx = canvas.getContext("2d")!;
  ctx.font = "bold 36px monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#fff";
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 4;

  ctx.strokeText(String(value), canvas.width / 2, canvas.height / 2);
  ctx.fillText(String(value), canvas.width / 2, canvas.height / 2);

  const texture = new Texture(canvas);
  texture.needsUpdate = true;

  const material = new SpriteMaterial({ map: texture, depthTest: false });
  const sprite = new Sprite(material);
  sprite.position.set(position.x, position.y, position.z);
  sprite.scale.set(0.5, 0.25, 1);
  return sprite;
}
